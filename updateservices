#!/usr/bin/perl
#
# $Id: updateservices,v 1.1 2001-12-10 19:50:28 garlick Exp $
# $Source: /g/g0/achu/temp/genders-cvsbackup-full/genders/updateservices,v $
#
# Author: Jim Garlick <garlick@llnl.gov>
#
# Update entries in /etc/services from /etc/services.add
#

$path_services = 	"/etc/services";
$path_services_bak = 	"/etc/services~";
$path_services_add = 	"/etc/services.add";

$prog = 		"updateservices";


my (%namesByPort, %commentsByPort);

copyFile($path_services, $path_services_bak);
parseServices($path_services,     \%namesByPort, \%commentsByPort);
parseServices($path_services_add, \%namesByPort, \%commentsByPort);
writeServices($path_services,     \%namesByPort, \%commentsByPort);

exit(0);

##
## SUBROUTINES
##

use strict;

# Copy a file
# 	$from (IN)	file to copy from
#	$to (IN)	file to copy to
sub copyFile
{
	my ($from, $to) = @_;

	if (open(OUTFILE, "> $to")) {
		if (open(INFILE, "< $from")) {
			while (<INFILE>) {
				printf OUTFILE ("$_");
			}
			close(INFILE);
		} else {
			printf STDERR ("$main::prog: can't read %s\n", $from);
			exit(1);
		}	
		close(OUTFILE);
	} else {
		printf STDERR ("$main::prog: can't create %s\n", $to);
		exit(1);
	}
}

# Parse a services file and put the results in the two hashes.
# There is only one comment per port in the comment hash, and the last
# one read will be the one that is printed.  Names will only appear once
# in the name hash.
#	$filename (IN)		name of services file
#	\%names (IN/OUT)	hash of names by port
#	\%comments (IN/OUT)	hash of comments by port
sub parseServices
{
	my ($filename, $names, $comments) = @_;
	my ($comment, $port, @fields, @names, $name);
	my ($line, $linenum);

	if (open(INFILE, "< $filename")) {
		while (<INFILE>) {
			# kerberos    88/tcp   kerberos5 krb5  # Kerberos v5

			chomp;
			$line = $_;
			$linenum++;

			# XXX lines containing only comments are lost
			if (s/(\#.*)//) {
				$comment = $1;
			} else {
				$comment = "";
			}
			next if (/^\s*$/);

			# extract list of names and port
			@fields = split();
			@names = (shift(@fields));
			$port = sprintf("%-6.6d/%s", 
			    split(/\//, shift(@fields), 2));
			push(@names, @fields);

			if (!@names) {
				printf STDERR ("%s: error on line %d: %s\n",
				    $main::prog, $linenum, $line);
				exit(1);
			}

			# construct hash of lists of names, by port
			foreach $name (@names) {
				if (!(grep(/^$name$/, @{${$names}{$port}}))) {
					push(@{${$names}{$port}}, $name);
				}
			}
			# construct hash of comments by port
			${$comments}{$port} = $comment;
		}
		close(INFILE);
	} else {
		printf STDERR ("%s: failed to open $filename\n", $main::prog);
		exit(1);
	}
}

# Take two hashes (created by parseServices) and reconstruct a services file.
#	$filename (IN)		name of services file (will be overwritten)
#	\%names (IN)		hash of names by port
#	\%comments (IN)		hash of comments by port
sub writeServices
{
	my ($filename, $names, $comments) = @_;
	my ($priName, $secNames, @names, $port, $key);

	if (open(OUTFILE, "> $filename")) {
		# first add a little text so users don't edit this file
		printf OUTFILE ("#\n");
		printf OUTFILE ("# This file automatically generated by %s\n", 
		    $main::prog);
		printf OUTFILE ("# DO NOT EDIT\n");
		printf OUTFILE ("#\n");

		foreach $key (sort(keys(%{$names}))) {
			@names = @{${$names}{$key}};
			$priName = shift(@names);
			$secNames = join(" ", @names);
			$port = sprintf("%d/%s", split(/\//, $key, 2));

			printf OUTFILE ("%-15s %-10s %-15s %s\n", 
			    $priName, $port, $secNames, ${$comments}{$key});
		}
		close(OUTFILE);
	} else {
		printf STDERR ("%s: can't write to %s\n", 
		    $main::prog, $filename);
		exit(1);
	}
}
